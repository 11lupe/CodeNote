# CSRF攻击与防御

参考：https://blog.csdn.net/stpeace/article/details/53512283

## CSRF概念

CSRF概念：CSRF跨站点请求伪造(Cross Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性。攻击者盗用了你的身份，以你的名义发送恶意请求，虽然对服务器来说这个请求是安全合法的。攻击者可能以你的名义发送邮件、发信息、盗取你的帐号，甚至是购买商品。

[图片]

CSRF攻击过程：

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息用过验证后，网站A产生Cookie信息并返回给浏览器。此时用户登录网站A成功，可以正常发送请求给网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到请求后，返回一些攻击性代码，同时发出一个请求要求访问去访问网站A；
5. 用户的浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
6. 网站A收到请求，并用过Cookies信息通过验证，执行了恶意代码



### CSRF漏洞检测

检测CDRF最简单的方法：对正常请求的数据包，去掉Referer字段后再重新提交，如果仍然可以正常访问，那么基本可以确认存在CSRF漏洞。

> Referer字段：HTTP表头的一个字段，表示HTTP来源地址，即从哪里链接到目前的网页。也就是说，通过Referer，可以检查出方可从哪里而来，这也常被用来防盗链和防止恶意请求。

工具检测：（CSRFTester）通过修改相应的表单再重新提交，相当于一次伪造客户端请求。如果修改后的测试请求请求成功，则说明存在CSRF漏洞。



### 防御CSRF攻击

防御CSRF攻击主要有三种策略：

1. 验证HTTP Referer字段
   对请求验证其Referer字段，是允许的来源地址时才可以访问

   - 简单易行，相当与白名单校验
   - 依赖第三方(即浏览器)保障，但有些浏览器可以篡改Referer值，达到通过校验的目的
   - Referer会记录访问来源，用户可能会设置发送请求时不提供Referer值，导致无法通过验证

2. 在请求地址中添加token并验证
   在请求中加入不能伪造的信息(随机产生的tooken)作为参数，并且该信息不存在Cookie中；在服务器段对这个信息进行校验
   token生成：服务端在用户登陆后生成token并放在session中，然后每次都与请求中的token进行对比
   请求过程中，对于GET请求，将token附在请求地址之后；对于POST请求，放入表单中

   - 比验证Referer要安全
   - 每次请求都要进行添加，容易遗漏
   - 难以保证token本身的安全，虽然可以通过Referer字段来判断是否需要携带token值，但Referer本身就有可能被篡改

3. 在HTTP头中自定义属性并验证
   将token放到HTTP头中自定义的属性中，通过XMLRequest这个类，可以一次性给所有该类请求加上这个HTTP头属性。通过XMLRequest请求的地址也不会被记录到浏览器的地址栏中，无需担心token会透过Referer泄漏到其它网站上去。

   - 这类请求通常用于Ajax方法红对于局部页面的异步刷新，但并非所有请求都合适
   - 通过这种请求得到的页面不能被浏览器记录，不方便进行前进、后退、刷新、收藏的操作
   - 对于已开发的系统，要采用这种方法进行防护，就要把所有请求都改为XMLRequest请求，代价太大

   

Flask csrf 
参考 https://blog.csdn.net/rongDang/article/details/81076567